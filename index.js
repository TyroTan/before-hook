"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CreateInstance = exports.BodyParserMiddleware = exports.BaseMiddleware = void 0;

require("source-map-support/register");

const SYMBOL_ERR_TYPE = Symbol("SYMBOL_BEFOREHOOK_ERR_TYPE");
const SYMBOL_SHORT_CIRCUIT_TYPE = Symbol("SYMBOL_BEFOREHOOK_SHORT_CIRCUIT_TYPE");
const SYMBOL_MIDDLEWARE_ON_CATCH = Symbol("SYMBOL_BEFOREHOOK_MIDDLEWARE_ON_CATCH");
const SYMBOL_MIDDLEWARE_ID = Symbol("SYMBOL_BEFOREHOOK_MIDDLEWARE_ID");

const isError = e => {
  return e && e.stack && e.message;
};

const objectAssignIfExists = (...args) => {
  const def = { ...args[1]
  };
  const overrideIfExist = { ...args[2]
  };
  Object.keys(def).forEach(k => {
    if (overrideIfExist[k]) {
      def[k] = overrideIfExist[k];
    }
  });
  return { ...args[0],
    ...def
  };
};

const MiddlewareHelpersInit = () => {
  const pvtLogger = {
    /* eslint-disable-next-line no-console */
    log: (...args) => args.forEach(l => console.log(l.message || l)),

    /* eslint-disable-next-line no-console */
    logError: (...args) => args.forEach(l => console.error(l.message || l))
  };

  const reply = obj => {
    // TODO: this is redundunt to another declaration of reply

    /* eslint-disable-next-line no-param-reassign */
    const customError = Error(JSON.stringify(obj));
    customError[SYMBOL_ERR_TYPE] = true;
    customError[SYMBOL_SHORT_CIRCUIT_TYPE] = "reply";
    throw customError;
  };

  return () => ({
    reply,
    getLogger: () => pvtLogger
  });
};
/* deprecated const setState = (objs, oldState, state) => {
  const mutatedOldState = oldState;
  const newState = state;

  Object.keys(objs).forEach(key => {
    newState[key] = objs[key];
    mutatedOldState[key] = objs[key];
  });

  return mutatedOldState;
};
const setContext = setState; */

/* deprecated const simpleClone = objectToClone =>
  /* JSON.parse(JSON.stringify( * / objectToClone; /* )) * /
const clone = simpleClone; */


const BaseMiddlewareHandlerInit = handler => {
  const dispatchFn = async (...options) => {
    const [instanceMethods, ...args] = options;
    const {
      getStateTree
    } = instanceMethods;

    try {
      await handler({
        getParams: () => args,
        reply: obj => {
          /* eslint-disable-next-line no-param-reassign */
          const shortCircuitErrorObject = Error(JSON.stringify(obj));
          shortCircuitErrorObject[SYMBOL_ERR_TYPE] = true;
          shortCircuitErrorObject[SYMBOL_SHORT_CIRCUIT_TYPE] = "reply";
          throw shortCircuitErrorObject;
        },
        next: () => {
          const shortCircuitErrorObject = Error("next is called.");
          shortCircuitErrorObject[SYMBOL_SHORT_CIRCUIT_TYPE] = "next";
        },
        getHelpers: MiddlewareHelpersInit()
      }, { ...getStateTree()
      } // TODO: Non-built-in methods
      );
    } catch (error) {
      /* ignore, next() is called */
      if (error[SYMBOL_SHORT_CIRCUIT_TYPE] === "next") {
        return args;
      }

      throw error;
    }

    return args;
  };

  return dispatchFn;
};

const BaseMiddleware = ({
  handler,
  configure
} = {}) => {
  if (!(typeof handler === "function")) {
    throw Error(`Custom middlewares must define a "handler"`);
  }

  let pre = async () => {};

  pre = BaseMiddlewareHandlerInit(handler);
  pre[SYMBOL_MIDDLEWARE_ID] = true;

  if (configure && configure.augmentMethods) {
    const {
      augmentMethods = {}
    } = configure;
    const configurableMethods = ["onCatch"];
    configurableMethods.forEach(fnName => {
      const newMethod = augmentMethods[fnName];

      if (typeof newMethod === "function") {
        if (fnName === "onCatch") {
          pre[SYMBOL_MIDDLEWARE_ON_CATCH] = (oldMethod, e, params) => {
            return newMethod(() => oldMethod(e), {
              prevRawMethod: oldMethod,
              arg: e,
              ...params
            });
          };
        }
      }
    });
  }

  return pre;
};

exports.BaseMiddleware = BaseMiddleware;

const BodyParserMiddleware = () => {
  return BaseMiddleware({
    handler: async ({
      getParams
    }) => {
      const [event] = getParams();

      if (Object.keys({ ...event.body
      }).length) {
        event.body = JSON.parse(event.body);
      }
    }
  });
};

exports.BodyParserMiddleware = BodyParserMiddleware;

const CreateInstance = options => {
  let settings = {
    DEBUG: false,
    stopOnCatch: true,
    register: []
  };
  settings = objectAssignIfExists({}, settings, options);
  let pvtDispatched = false;
  const stackedHooks = [];
  let isHandlerFed = false;
  let handlerLength = -1;

  let handler = async () => {};

  let FODispatch = async () => {};
  /*
   *
   * CONFIGURABLES - START
   *
   */


  let pvtLogger = {
    /* eslint-disable-next-line no-console */
    log: (...args) => args.forEach(l => console.log(l.message || l)),

    /* eslint-disable-next-line no-console */
    logError: (...args) => args.forEach(l => console.error(l.message || l)),
    logWarning: (...args) =>
    /* eslint-disable-next-line no-console */
    args.forEach(l => console.error(`WARNING: ${l.message || l}`))
  };
  /* logs are off by default */

  if (settings.DEBUG !== true) {
    pvtLogger.log = () => {};

    pvtLogger.logError = () => {};

    pvtLogger.logWarning = () => {};
  }
  /* start plugins state tree */


  const stateTree = {};

  const setStateTree = (treeKey, obj) => {
    if (typeof stateTree[treeKey] === 'undefined') {
      /* eslint-disable-next-line prefer-destructuring */
      stateTree[treeKey] = obj;
      return;
    }

    throw Error(`tree key "${treeKey}" already in use`);
  };

  const getStateTree = () => stateTree;
  /* end plugins state tree */


  let onReturnObject = args => args;

  const onReply = (...args) => onReturnObject(...args);

  let onCatch = (...args) => {
    const [e] = args;

    if (!isError(e)) {
      pvtLogger.logError(`Short circuit handler onCatch is expecting an Error but got ${e.toString && e.toString()}`); // TODO: expose "reply" instead and not prevMethod...

      if (typeof e === "object" && e.statusCode >= 400) {
        return onReturnObject(e);
      }
    }

    try {
      if (e[SYMBOL_ERR_TYPE] === true) {
        // if (e[SYMBOL_SHORT_CIRCUIT_TYPE] === "reply") {
        //   return onReply(JSON.parse(e.message));
        // }
        return onReturnObject(JSON.parse(e.message));
      }

      pvtLogger.logError(e);
      return onReturnObject({
        statusCode: 500,
        body: `${e.message}`
      });
    } catch (parseError) {
      pvtLogger.logError(parseError);
      return onReturnObject({
        statusCode: 500,
        body: `${parseError.message} - ${e && e.message ? e.message : ""}`
      });
    }
  };

  let handlerCallWrapper = (...args) => {
    return handler(...args);
  };
  /**
   *
   * CONFIGURABLES - END
   *
   * */


  const configure = ({
    augmentMethods = {}
  } = {}) => {
    const configurableMethods = ["onCatch", "onReturnObject", "handlerCallWrapper", "pvtLogger"];
    configurableMethods.forEach(fnName => {
      const newMethod = augmentMethods[fnName];

      if (typeof newMethod === "function") {
        if (fnName === "onReturnObject") {
          const oldMethod = onReturnObject;

          onReturnObject = (arg1, params) => {
            return newMethod(() => oldMethod(arg1), {
              prevRawMethod: oldMethod,
              arg: arg1,
              ...params
            });
          };
        } else if (fnName === "onCatch") {
          const oldMethod = onCatch;

          onCatch = (arg1, params) => {
            return newMethod(() => oldMethod(arg1), {
              prevRawMethod: oldMethod,
              arg: arg1,
              ...params
            });
          };
        } else if (fnName === "handlerCallWrapper") {
          const oldMethod = handlerCallWrapper;

          handlerCallWrapper = e => {
            return newMethod(() => oldMethod(e), {
              prevRawMethod: oldMethod,
              arg: e
            });
          };
        } else if (fnName === "pvtLogger") {
          const oldMethod = pvtLogger;

          pvtLogger = e => {
            return newMethod(() => oldMethod(e), {
              prevRawMethod: oldMethod,
              arg: e
            });
          };
        }
      }
    });
  };
  /* init configurables */


  if (options && options.configure) {
    configure(options.configure);
  }
  /**
   *
   * CORE - START
   *
   * */

  /* Function Object Init "Before Hook" */


  const FOInitBeforeHook = (...args) => {
    if (isHandlerFed === true) {
      handlerLength = handler.length;
    }

    if (typeof args[0] === "undefined") {
      pvtLogger.logWarning(`"undefined" is probably not expected here.`);
    }

    if (isHandlerFed === false && Array.isArray(args[0])) {
      if (args[0].every(fn => typeof fn === "function")) {
        const FOArray = args[0].map(item => CreateInstance(options)(item));

        FOArray.use = (...useArgs) => {
          const FOArrayInner = FOArray.map(instance => instance.use(...useArgs));
          FOArrayInner.use = FOArray.use;
          return FOArrayInner;
        };

        return FOArray;
      }

      throw Error("before-hook can only be used for functions. One of the items in array is not.");
    } else if (typeof args[0] !== "function") {
      if (handlerLength > -1 && handlerLength !== args.length) {
        pvtLogger.logWarning(`Dispatching with ${args.length} args while the original handler has ${handlerLength}.`);
      }

      if (Array.isArray(args[0])) {
        /* eslint-disable-next-line no-console */
        console.error(`[DEPRECATED] -
        This action will execute your hooked function given the array argument.
        If you intended to hook an array of functions instead.
        Please use beforeHook.getNew.`);
      }

      return FODispatch(...args);
    }

    if (isHandlerFed === true && args[0][SYMBOL_MIDDLEWARE_ID] !== true) {
      /* then we assume this scenario calls for a new instance */
      return CreateInstance(options)(args[0]);
    }
    /* eslint-disable-next-line */


    handler = args[0];
    isHandlerFed = true;
    return FODispatch;
  };

  FOInitBeforeHook.getNew = arrayOfFunctions => {
    if (!Array.isArray(arrayOfFunctions)) {
      throw Error(`Expecting an array argument but type "${typeof arrayOfFunctions}" was passed.`);
    }

    if (arrayOfFunctions.every(fn => typeof fn === "function")) {
      const FOArray = arrayOfFunctions.map(item => CreateInstance(options)(item));

      FOArray.use = (...useArgs) => {
        const FOArrayInner = FOArray.map(instance => instance.use(...useArgs));
        FOArrayInner.use = FOArray.use;
        return FOArrayInner;
      };

      return FOArray;
    }

    throw Error("before-hook can only be used for functions. One of the items in array is not.");
  };

  FOInitBeforeHook.use = (...args) => {
    if (!args || !args[0]) {
      throw Error(`.use expects an instance from BaseMiddleware. (Got type "${typeof args[0]}")`);
    }

    if (isHandlerFed === false) {
      throw Error("A handler needs to be fed first before calling .use");
    }

    if (args.length > 1) {
      pvtLogger.logWarning(`Ignoring 2nd argument. "use" method was called with more than 1 argument.`);
    }

    if (pvtDispatched === true) {
      throw Error("Using middlewares again after handler's invocation is not allowed.");
    }

    const middleware = args[0];

    if (middleware[SYMBOL_MIDDLEWARE_ID] === true) {
      stackedHooks.push(middleware);
    } else {
      throw Error("Unknown middleware. Middlewares must extend BaseMiddleware.");
    }

    return FOInitBeforeHook;
  };

  FOInitBeforeHook.setLogger = newLogger => {
    pvtLogger = newLogger;
  };

  FOInitBeforeHook.getLogger = () => pvtLogger;

  FODispatch = async (...args) => {
    let hookBeforeCatching = {};
    pvtDispatched = true;

    if (Array.isArray(settings.register) && settings.register.length) {
      // TODO: support loading async plugins
      settings.register.forEach(pluginFn => {
        pluginFn({
          getParams: () => args,
          addTree: setStateTree
        });
      });
    }

    try {
      /* eslint-disable-next-line no-restricted-syntax */
      for (const hook of stackedHooks) {
        hookBeforeCatching = hook;
        /* eslint-disable-next-line no-await-in-loop */

        await hook({
          getStateTree
        }, ...args); // const extensions = await hook(...args);
      }
    } catch (middlewaresThrow) {
      if (middlewaresThrow[SYMBOL_SHORT_CIRCUIT_TYPE] === "reply") {
        if (settings.stopOnCatch === true) {
          return onReply(JSON.parse(middlewaresThrow.message));
        }
      }

      const catchHandlerToUse = typeof hookBeforeCatching[SYMBOL_MIDDLEWARE_ON_CATCH] === "function" ? (err, params) => hookBeforeCatching[SYMBOL_MIDDLEWARE_ON_CATCH](e => onCatch(e, params), err, params) : (err, params) => onCatch(err, params);

      if (settings.stopOnCatch === true) {
        return catchHandlerToUse(middlewaresThrow, {
          getParams: () => args
        });
      }

      catchHandlerToUse(middlewaresThrow, {
        getParams: () => args
      });
    }

    return handlerCallWrapper(...args);
  };
  /* copy properties of FOInitBeforeHook to FODispatch - so we can chain .use and etc */


  Object.keys(FOInitBeforeHook).forEach(method => {
    FODispatch[method] = FOInitBeforeHook[method];
  });
  /**
   *
   * CORE - END
   *
   * */

  return FOInitBeforeHook;
};

exports.CreateInstance = CreateInstance;
var _default = CreateInstance;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LnNvdXJjZS5qcyJdLCJuYW1lcyI6WyJTWU1CT0xfRVJSX1RZUEUiLCJTeW1ib2wiLCJTWU1CT0xfU0hPUlRfQ0lSQ1VJVF9UWVBFIiwiU1lNQk9MX01JRERMRVdBUkVfT05fQ0FUQ0giLCJTWU1CT0xfTUlERExFV0FSRV9JRCIsImlzRXJyb3IiLCJlIiwic3RhY2siLCJtZXNzYWdlIiwib2JqZWN0QXNzaWduSWZFeGlzdHMiLCJhcmdzIiwiZGVmIiwib3ZlcnJpZGVJZkV4aXN0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrIiwiTWlkZGxld2FyZUhlbHBlcnNJbml0IiwicHZ0TG9nZ2VyIiwibG9nIiwibCIsImNvbnNvbGUiLCJsb2dFcnJvciIsImVycm9yIiwicmVwbHkiLCJvYmoiLCJjdXN0b21FcnJvciIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldExvZ2dlciIsIkJhc2VNaWRkbGV3YXJlSGFuZGxlckluaXQiLCJoYW5kbGVyIiwiZGlzcGF0Y2hGbiIsIm9wdGlvbnMiLCJpbnN0YW5jZU1ldGhvZHMiLCJnZXRTdGF0ZVRyZWUiLCJnZXRQYXJhbXMiLCJzaG9ydENpcmN1aXRFcnJvck9iamVjdCIsIm5leHQiLCJnZXRIZWxwZXJzIiwiQmFzZU1pZGRsZXdhcmUiLCJjb25maWd1cmUiLCJwcmUiLCJhdWdtZW50TWV0aG9kcyIsImNvbmZpZ3VyYWJsZU1ldGhvZHMiLCJmbk5hbWUiLCJuZXdNZXRob2QiLCJvbGRNZXRob2QiLCJwYXJhbXMiLCJwcmV2UmF3TWV0aG9kIiwiYXJnIiwiQm9keVBhcnNlck1pZGRsZXdhcmUiLCJldmVudCIsImJvZHkiLCJsZW5ndGgiLCJwYXJzZSIsIkNyZWF0ZUluc3RhbmNlIiwic2V0dGluZ3MiLCJERUJVRyIsInN0b3BPbkNhdGNoIiwicmVnaXN0ZXIiLCJwdnREaXNwYXRjaGVkIiwic3RhY2tlZEhvb2tzIiwiaXNIYW5kbGVyRmVkIiwiaGFuZGxlckxlbmd0aCIsIkZPRGlzcGF0Y2giLCJsb2dXYXJuaW5nIiwic3RhdGVUcmVlIiwic2V0U3RhdGVUcmVlIiwidHJlZUtleSIsIm9uUmV0dXJuT2JqZWN0Iiwib25SZXBseSIsIm9uQ2F0Y2giLCJ0b1N0cmluZyIsInN0YXR1c0NvZGUiLCJwYXJzZUVycm9yIiwiaGFuZGxlckNhbGxXcmFwcGVyIiwiYXJnMSIsIkZPSW5pdEJlZm9yZUhvb2siLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsImZuIiwiRk9BcnJheSIsIm1hcCIsIml0ZW0iLCJ1c2UiLCJ1c2VBcmdzIiwiRk9BcnJheUlubmVyIiwiaW5zdGFuY2UiLCJnZXROZXciLCJhcnJheU9mRnVuY3Rpb25zIiwibWlkZGxld2FyZSIsInB1c2giLCJzZXRMb2dnZXIiLCJuZXdMb2dnZXIiLCJob29rQmVmb3JlQ2F0Y2hpbmciLCJwbHVnaW5GbiIsImFkZFRyZWUiLCJob29rIiwibWlkZGxld2FyZXNUaHJvdyIsImNhdGNoSGFuZGxlclRvVXNlIiwiZXJyIiwibWV0aG9kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxNQUFNQSxlQUFlLEdBQUdDLE1BQU0sQ0FBQyw0QkFBRCxDQUE5QjtBQUNBLE1BQU1DLHlCQUF5QixHQUFHRCxNQUFNLENBQ3RDLHNDQURzQyxDQUF4QztBQUdBLE1BQU1FLDBCQUEwQixHQUFHRixNQUFNLENBQ3ZDLHVDQUR1QyxDQUF6QztBQUdBLE1BQU1HLG9CQUFvQixHQUFHSCxNQUFNLENBQUMsaUNBQUQsQ0FBbkM7O0FBRUEsTUFBTUksT0FBTyxHQUFHQyxDQUFDLElBQUk7QUFDbkIsU0FBT0EsQ0FBQyxJQUFJQSxDQUFDLENBQUNDLEtBQVAsSUFBZ0JELENBQUMsQ0FBQ0UsT0FBekI7QUFDRCxDQUZEOztBQUlBLE1BQU1DLG9CQUFvQixHQUFHLENBQUMsR0FBR0MsSUFBSixLQUFhO0FBQ3hDLFFBQU1DLEdBQUcsR0FBRyxFQUFFLEdBQUdELElBQUksQ0FBQyxDQUFEO0FBQVQsR0FBWjtBQUNBLFFBQU1FLGVBQWUsR0FBRyxFQUFFLEdBQUdGLElBQUksQ0FBQyxD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Q0QsR0FGRDtBQUlBOzs7Ozs7QUFNQSxTQUFPekIsZ0JBQVA7QUFDRCxDQXRXRDs7O2VBMFdldEIsYyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNZTUJPTF9FUlJfVFlQRSA9IFN5bWJvbChcIlNZTUJPTF9CRUZPUkVIT09LX0VSUl9UWVBFXCIpO1xuY29uc3QgU1lNQk9MX1NIT1JUX0NJUkNVSVRfVFlQRSA9IFN5bWJvbChcbiAgXCJTWU1CT0xfQkVGT1JFSE9PS19TSE9SVF9DSVJDVUlUX1RZUEVcIlxuKTtcbmNvbnN0IFNZTUJPTF9NSURETEVXQVJFX09OX0NBVENIID0gU3ltYm9sKFxuICBcIlNZTUJPTF9CRUZPUkVIT09LX01JRERMRVdBUkVfT05fQ0FUQ0hcIlxuKTtcbmNvbnN0IFNZTUJPTF9NSURETEVXQVJFX0lEID0gU3ltYm9sKFwiU1lNQk9MX0JFRk9SRUhPT0tfTUlERExFV0FSRV9JRFwiKTtcblxuY29uc3QgaXNFcnJvciA9IGUgPT4ge1xuICByZXR1cm4gZSAmJiBlLnN0YWNrICYmIGUubWVzc2FnZTtcbn07XG5cbmNvbnN0IG9iamVjdEFzc2lnbklmRXhpc3RzID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgZGVmID0geyAuLi5hcmdzWzFdIH07XG4gIGNvbnN0IG92ZXJyaWRlSWZFeGlzdCA9IHsgLi4uYXJnc1syXSB9O1xuICBPYmplY3Qua2V5cyhkZWYpLmZvckVhY2goayA9PiB7XG4gICAgaWYgKG92ZXJyaWRlSWZFeGlzdFtrXSkge1xuICAgICAgZGVmW2tdID0gb3ZlcnJpZGVJZkV4aXN0W2tdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHsgLi4uYXJnc1swXSwgLi4uZGVmIH07XG59O1xuXG5jb25zdCBNaWRkbGV3YXJlSGVscGVyc0luaXQgPSAoKSA9PiB7XG4gIGNvbnN0IHB2dExvZ2dlciA9IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSAqL1xuICAgIGxvZzogKC4uLmFyZ3MpID0+IGFyZ3MuZm9yRWFjaChsID0+IGNvbnNvbGUubG9nKGwubWVzc2FnZSB8fCBsKSksXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSAqL1xuICAgIGxvZ0Vycm9yOiAoLi4uYXJncykgPT4gYXJncy5mb3JFYWNoKGwgPT4gY29uc29sZS5lcnJvcihsLm1lc3NhZ2UgfHwgbCkpXG4gIH07XG5cbiAgY29uc3QgcmVwbHkgPSBvYmogPT4ge1xuICAgIC8vIFRPRE86IHRoaXMgaXMgcmVkdW5kdW50IHRvIGFub3RoZXIgZGVjbGFyYXRpb24gb2YgcmVwbHlcblxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgIGNvbnN0IGN1c3RvbUVycm9yID0gRXJyb3IoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgY3VzdG9tRXJyb3JbU1lNQk9MX0VSUl9UWVBFXSA9IHRydWU7XG4gICAgY3VzdG9tRXJyb3JbU1lNQk9MX1NIT1JUX0NJUkNVSVRfVFlQRV0gPSBcInJlcGx5XCI7XG5cbiAgICB0aHJvdyBjdXN0b21FcnJvcjtcbiAgfTtcblxuICByZXR1cm4gKCkgPT4gKHtcbiAgICByZXBseSxcbiAgICBnZXRMb2dnZXI6ICgpID0+IHB2dExvZ2dlclxuICB9KTtcbn07XG5cbi8qIGRlcHJlY2F0ZWQgY29uc3Qgc2V0U3RhdGUgPSAob2Jqcywgb2xkU3RhdGUsIHN0YXRlKSA9PiB7XG4gIGNvbnN0IG11dGF0ZWRPbGRTdGF0ZSA9IG9sZFN0YXRlO1xuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xuXG4gIE9iamVjdC5rZXlzKG9ianMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBuZXdTdGF0ZVtrZXldID0gb2Jqc1trZXldO1xuICAgIG11dGF0ZWRPbGRTdGF0ZVtrZXldID0gb2Jqc1trZXldO1xuICB9KTtcblxuICByZXR1cm4gbXV0YXRlZE9sZFN0YXRlO1xufTtcbmNvbnN0IHNldENvbnRleHQgPSBzZXRTdGF0ZTsgKi9cbi8qIGRlcHJlY2F0ZWQgY29uc3Qgc2ltcGxlQ2xvbmUgPSBvYmplY3RUb0Nsb25lID0+XG4gIC8qIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoICogLyBvYmplY3RUb0Nsb25lOyAvKiApKSAqIC9cbmNvbnN0IGNsb25lID0gc2ltcGxlQ2xvbmU7ICovXG5cbmNvbnN0IEJhc2VNaWRkbGV3YXJlSGFuZGxlckluaXQgPSBoYW5kbGVyID0+IHtcbiAgY29uc3QgZGlzcGF0Y2hGbiA9IGFzeW5jICguLi5vcHRpb25zKSA9PiB7XG4gICAgY29uc3QgW2luc3RhbmNlTWV0aG9kcywgLi4uYXJnc10gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgZ2V0U3RhdGVUcmVlIH0gPSBpbnN0YW5jZU1ldGhvZHM7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGhhbmRsZXIoXG4gICAgICAgIHtcbiAgICAgICAgICBnZXRQYXJhbXM6ICgpID0+IGFyZ3MsXG4gICAgICAgICAgcmVwbHk6IG9iaiA9PiB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgIGNvbnN0IHNob3J0Q2lyY3VpdEVycm9yT2JqZWN0ID0gRXJyb3IoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgICAgICAgICBzaG9ydENpcmN1aXRFcnJvck9iamVjdFtTWU1CT0xfRVJSX1RZUEVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHNob3J0Q2lyY3VpdEVycm9yT2JqZWN0W1NZTUJPTF9TSE9SVF9DSVJDVUlUX1RZUEVdID0gXCJyZXBseVwiO1xuXG4gICAgICAgICAgICB0aHJvdyBzaG9ydENpcmN1aXRFcnJvck9iamVjdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNob3J0Q2lyY3VpdEVycm9yT2JqZWN0ID0gRXJyb3IoXCJuZXh0IGlzIGNhbGxlZC5cIik7XG4gICAgICAgICAgICBzaG9ydENpcmN1aXRFcnJvck9iamVjdFtTWU1CT0xfU0hPUlRfQ0lSQ1VJVF9UWVBFXSA9IFwibmV4dFwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0SGVscGVyczogTWlkZGxld2FyZUhlbHBlcnNJbml0KClcbiAgICAgICAgfSxcbiAgICAgICAgeyAuLi5nZXRTdGF0ZVRyZWUoKSB9IC8vIFRPRE86IE5vbi1idWlsdC1pbiBtZXRob2RzXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvKiBpZ25vcmUsIG5leHQoKSBpcyBjYWxsZWQgKi9cbiAgICAgIGlmIChlcnJvcltTWU1CT0xfU0hPUlRfQ0lSQ1VJVF9UWVBFXSA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBhcmdzO1xuICB9O1xuXG4gIHJldHVybiBkaXNwYXRjaEZuO1xufTtcblxuY29uc3QgQmFzZU1pZGRsZXdhcmUgPSAoeyBoYW5kbGVyLCBjb25maWd1cmUgfSA9IHt9KSA9PiB7XG4gIGlmICghKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEN1c3RvbSBtaWRkbGV3YXJlcyBtdXN0IGRlZmluZSBhIFwiaGFuZGxlclwiYCk7XG4gIH1cblxuICBsZXQgcHJlID0gYXN5bmMgKCkgPT4ge307XG4gIHByZSA9IEJhc2VNaWRkbGV3YXJlSGFuZGxlckluaXQoaGFuZGxlcik7XG5cbiAgcHJlW1NZTUJPTF9NSURETEVXQVJFX0lEXSA9IHRydWU7XG5cbiAgaWYgKGNvbmZpZ3VyZSAmJiBjb25maWd1cmUuYXVnbWVudE1ldGhvZHMpIHtcbiAgICBjb25zdCB7IGF1Z21lbnRNZXRob2RzID0ge30gfSA9IGNvbmZpZ3VyZTtcbiAgICBjb25zdCBjb25maWd1cmFibGVNZXRob2RzID0gW1wib25DYXRjaFwiXTtcblxuICAgIGNvbmZpZ3VyYWJsZU1ldGhvZHMuZm9yRWFjaChmbk5hbWUgPT4ge1xuICAgICAgY29uc3QgbmV3TWV0aG9kID0gYXVnbWVudE1ldGhvZHNbZm5OYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZiBuZXdNZXRob2QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoZm5OYW1lID09PSBcIm9uQ2F0Y2hcIikge1xuICAgICAgICAgIHByZVtTWU1CT0xfTUlERExFV0FSRV9PTl9DQVRDSF0gPSAob2xkTWV0aG9kLCBlLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXdNZXRob2QoKCkgPT4gb2xkTWV0aG9kKGUpLCB7XG4gICAgICAgICAgICAgIHByZXZSYXdNZXRob2Q6IG9sZE1ldGhvZCxcbiAgICAgICAgICAgICAgYXJnOiBlLFxuICAgICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwcmU7XG59O1xuXG5jb25zdCBCb2R5UGFyc2VyTWlkZGxld2FyZSA9ICgpID0+IHtcbiAgcmV0dXJuIEJhc2VNaWRkbGV3YXJlKHtcbiAgICBoYW5kbGVyOiBhc3luYyAoeyBnZXRQYXJhbXMgfSkgPT4ge1xuICAgICAgY29uc3QgW2V2ZW50XSA9IGdldFBhcmFtcygpO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHsgLi4uZXZlbnQuYm9keSB9KS5sZW5ndGgpIHtcbiAgICAgICAgZXZlbnQuYm9keSA9IEpTT04ucGFyc2UoZXZlbnQuYm9keSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IENyZWF0ZUluc3RhbmNlID0gb3B0aW9ucyA9PiB7XG4gIGxldCBzZXR0aW5ncyA9IHtcbiAgICBERUJVRzogZmFsc2UsXG4gICAgc3RvcE9uQ2F0Y2g6IHRydWUsXG4gICAgcmVnaXN0ZXI6IFtdXG4gIH07XG5cbiAgc2V0dGluZ3MgPSBvYmplY3RBc3NpZ25JZkV4aXN0cyh7fSwgc2V0dGluZ3MsIG9wdGlvbnMpO1xuXG4gIGxldCBwdnREaXNwYXRjaGVkID0gZmFsc2U7XG4gIGNvbnN0IHN0YWNrZWRIb29rcyA9IFtdO1xuICBsZXQgaXNIYW5kbGVyRmVkID0gZmFsc2U7XG4gIGxldCBoYW5kbGVyTGVuZ3RoID0gLTE7XG5cbiAgbGV0IGhhbmRsZXIgPSBhc3luYyAoKSA9PiB7fTtcbiAgbGV0IEZPRGlzcGF0Y2ggPSBhc3luYyAoKSA9PiB7fTtcblxuICAvKlxuICAgKlxuICAgKiBDT05GSUdVUkFCTEVTIC0gU1RBUlRcbiAgICpcbiAgICovXG5cbiAgbGV0IHB2dExvZ2dlciA9IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSAqL1xuICAgIGxvZzogKC4uLmFyZ3MpID0+IGFyZ3MuZm9yRWFjaChsID0+IGNvbnNvbGUubG9nKGwubWVzc2FnZSB8fCBsKSksXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSAqL1xuICAgIGxvZ0Vycm9yOiAoLi4uYXJncykgPT4gYXJncy5mb3JFYWNoKGwgPT4gY29uc29sZS5lcnJvcihsLm1lc3NhZ2UgfHwgbCkpLFxuXG4gICAgbG9nV2FybmluZzogKC4uLmFyZ3MpID0+XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSAqL1xuICAgICAgYXJncy5mb3JFYWNoKGwgPT4gY29uc29sZS5lcnJvcihgV0FSTklORzogJHtsLm1lc3NhZ2UgfHwgbH1gKSlcbiAgfTtcblxuICAvKiBsb2dzIGFyZSBvZmYgYnkgZGVmYXVsdCAqL1xuICBpZiAoc2V0dGluZ3MuREVCVUcgIT09IHRydWUpIHtcbiAgICBwdnRMb2dnZXIubG9nID0gKCkgPT4ge307XG4gICAgcHZ0TG9nZ2VyLmxvZ0Vycm9yID0gKCkgPT4ge307XG4gICAgcHZ0TG9nZ2VyLmxvZ1dhcm5pbmcgPSAoKSA9PiB7fTtcbiAgfVxuXG4gIC8qIHN0YXJ0IHBsdWdpbnMgc3RhdGUgdHJlZSAqL1xuXG4gIGNvbnN0IHN0YXRlVHJlZSA9IHt9O1xuICBjb25zdCBzZXRTdGF0ZVRyZWUgPSAodHJlZUtleSwgb2JqKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZVRyZWVbdHJlZUtleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmcgKi9cbiAgICAgIHN0YXRlVHJlZVt0cmVlS2V5XSA9IG9iajtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJvdyBFcnJvcihgdHJlZSBrZXkgXCIke3RyZWVLZXl9XCIgYWxyZWFkeSBpbiB1c2VgKTtcbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGVUcmVlID0gKCkgPT4gc3RhdGVUcmVlO1xuXG4gIC8qIGVuZCBwbHVnaW5zIHN0YXRlIHRyZWUgKi9cblxuICBsZXQgb25SZXR1cm5PYmplY3QgPSBhcmdzID0+IGFyZ3M7XG4gIGNvbnN0IG9uUmVwbHkgPSAoLi4uYXJncykgPT4gb25SZXR1cm5PYmplY3QoLi4uYXJncyk7XG5cbiAgbGV0IG9uQ2F0Y2ggPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IFtlXSA9IGFyZ3M7XG5cbiAgICBpZiAoIWlzRXJyb3IoZSkpIHtcbiAgICAgIHB2dExvZ2dlci5sb2dFcnJvcihcbiAgICAgICAgYFNob3J0IGNpcmN1aXQgaGFuZGxlciBvbkNhdGNoIGlzIGV4cGVjdGluZyBhbiBFcnJvciBidXQgZ290ICR7ZS50b1N0cmluZyAmJlxuICAgICAgICAgIGUudG9TdHJpbmcoKX1gXG4gICAgICApO1xuXG4gICAgICAvLyBUT0RPOiBleHBvc2UgXCJyZXBseVwiIGluc3RlYWQgYW5kIG5vdCBwcmV2TWV0aG9kLi4uXG4gICAgICBpZiAodHlwZW9mIGUgPT09IFwib2JqZWN0XCIgJiYgZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICByZXR1cm4gb25SZXR1cm5PYmplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChlW1NZTUJPTF9FUlJfVFlQRV0gPT09IHRydWUpIHtcbiAgICAgICAgLy8gaWYgKGVbU1lNQk9MX1NIT1JUX0NJUkNVSVRfVFlQRV0gPT09IFwicmVwbHlcIikge1xuICAgICAgICAvLyAgIHJldHVybiBvblJlcGx5KEpTT04ucGFyc2UoZS5tZXNzYWdlKSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIG9uUmV0dXJuT2JqZWN0KEpTT04ucGFyc2UoZS5tZXNzYWdlKSk7XG4gICAgICB9XG5cbiAgICAgIHB2dExvZ2dlci5sb2dFcnJvcihlKTtcblxuICAgICAgcmV0dXJuIG9uUmV0dXJuT2JqZWN0KHtcbiAgICAgICAgc3RhdHVzQ29kZTogNTAwLFxuICAgICAgICBib2R5OiBgJHtlLm1lc3NhZ2V9YFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgcHZ0TG9nZ2VyLmxvZ0Vycm9yKHBhcnNlRXJyb3IpO1xuXG4gICAgICByZXR1cm4gb25SZXR1cm5PYmplY3Qoe1xuICAgICAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgICAgIGJvZHk6IGAke3BhcnNlRXJyb3IubWVzc2FnZX0gLSAke2UgJiYgZS5tZXNzYWdlID8gZS5tZXNzYWdlIDogXCJcIn1gXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IGhhbmRsZXJDYWxsV3JhcHBlciA9ICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIGhhbmRsZXIoLi4uYXJncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIENPTkZJR1VSQUJMRVMgLSBFTkRcbiAgICpcbiAgICogKi9cblxuICBjb25zdCBjb25maWd1cmUgPSAoeyBhdWdtZW50TWV0aG9kcyA9IHt9IH0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ3VyYWJsZU1ldGhvZHMgPSBbXG4gICAgICBcIm9uQ2F0Y2hcIixcbiAgICAgIFwib25SZXR1cm5PYmplY3RcIixcbiAgICAgIFwiaGFuZGxlckNhbGxXcmFwcGVyXCIsXG4gICAgICBcInB2dExvZ2dlclwiXG4gICAgXTtcblxuICAgIGNvbmZpZ3VyYWJsZU1ldGhvZHMuZm9yRWFjaChmbk5hbWUgPT4ge1xuICAgICAgY29uc3QgbmV3TWV0aG9kID0gYXVnbWVudE1ldGhvZHNbZm5OYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgbmV3TWV0aG9kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGZuTmFtZSA9PT0gXCJvblJldHVybk9iamVjdFwiKSB7XG4gICAgICAgICAgY29uc3Qgb2xkTWV0aG9kID0gb25SZXR1cm5PYmplY3Q7XG4gICAgICAgICAgb25SZXR1cm5PYmplY3QgPSAoYXJnMSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3TWV0aG9kKCgpID0+IG9sZE1ldGhvZChhcmcxKSwge1xuICAgICAgICAgICAgICBwcmV2UmF3TWV0aG9kOiBvbGRNZXRob2QsXG4gICAgICAgICAgICAgIGFyZzogYXJnMSxcbiAgICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gXCJvbkNhdGNoXCIpIHtcbiAgICAgICAgICBjb25zdCBvbGRNZXRob2QgPSBvbkNhdGNoO1xuICAgICAgICAgIG9uQ2F0Y2ggPSAoYXJnMSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3TWV0aG9kKCgpID0+IG9sZE1ldGhvZChhcmcxKSwge1xuICAgICAgICAgICAgICBwcmV2UmF3TWV0aG9kOiBvbGRNZXRob2QsXG4gICAgICAgICAgICAgIGFyZzogYXJnMSxcbiAgICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gXCJoYW5kbGVyQ2FsbFdyYXBwZXJcIikge1xuICAgICAgICAgIGNvbnN0IG9sZE1ldGhvZCA9IGhhbmRsZXJDYWxsV3JhcHBlcjtcbiAgICAgICAgICBoYW5kbGVyQ2FsbFdyYXBwZXIgPSBlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXdNZXRob2QoKCkgPT4gb2xkTWV0aG9kKGUpLCB7XG4gICAgICAgICAgICAgIHByZXZSYXdNZXRob2Q6IG9sZE1ldGhvZCxcbiAgICAgICAgICAgICAgYXJnOiBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gXCJwdnRMb2dnZXJcIikge1xuICAgICAgICAgIGNvbnN0IG9sZE1ldGhvZCA9IHB2dExvZ2dlcjtcbiAgICAgICAgICBwdnRMb2dnZXIgPSBlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXdNZXRob2QoKCkgPT4gb2xkTWV0aG9kKGUpLCB7XG4gICAgICAgICAgICAgIHByZXZSYXdNZXRob2Q6IG9sZE1ldGhvZCxcbiAgICAgICAgICAgICAgYXJnOiBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyogaW5pdCBjb25maWd1cmFibGVzICovXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29uZmlndXJlKSB7XG4gICAgY29uZmlndXJlKG9wdGlvbnMuY29uZmlndXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBDT1JFIC0gU1RBUlRcbiAgICpcbiAgICogKi9cblxuICAvKiBGdW5jdGlvbiBPYmplY3QgSW5pdCBcIkJlZm9yZSBIb29rXCIgKi9cbiAgY29uc3QgRk9Jbml0QmVmb3JlSG9vayA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKGlzSGFuZGxlckZlZCA9PT0gdHJ1ZSkge1xuICAgICAgaGFuZGxlckxlbmd0aCA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcHZ0TG9nZ2VyLmxvZ1dhcm5pbmcoYFwidW5kZWZpbmVkXCIgaXMgcHJvYmFibHkgbm90IGV4cGVjdGVkIGhlcmUuYCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSGFuZGxlckZlZCA9PT0gZmFsc2UgJiYgQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgaWYgKGFyZ3NbMF0uZXZlcnkoZm4gPT4gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIGNvbnN0IEZPQXJyYXkgPSBhcmdzWzBdLm1hcChpdGVtID0+IENyZWF0ZUluc3RhbmNlKG9wdGlvbnMpKGl0ZW0pKTtcbiAgICAgICAgRk9BcnJheS51c2UgPSAoLi4udXNlQXJncykgPT4ge1xuICAgICAgICAgIGNvbnN0IEZPQXJyYXlJbm5lciA9IEZPQXJyYXkubWFwKGluc3RhbmNlID0+XG4gICAgICAgICAgICBpbnN0YW5jZS51c2UoLi4udXNlQXJncylcbiAgICAgICAgICApO1xuICAgICAgICAgIEZPQXJyYXlJbm5lci51c2UgPSBGT0FycmF5LnVzZTtcbiAgICAgICAgICByZXR1cm4gRk9BcnJheUlubmVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBGT0FycmF5O1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiYmVmb3JlLWhvb2sgY2FuIG9ubHkgYmUgdXNlZCBmb3IgZnVuY3Rpb25zLiBPbmUgb2YgdGhlIGl0ZW1zIGluIGFycmF5IGlzIG5vdC5cIlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmIChoYW5kbGVyTGVuZ3RoID4gLTEgJiYgaGFuZGxlckxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcHZ0TG9nZ2VyLmxvZ1dhcm5pbmcoXG4gICAgICAgICAgYERpc3BhdGNoaW5nIHdpdGggJHtcbiAgICAgICAgICAgIGFyZ3MubGVuZ3RoXG4gICAgICAgICAgfSBhcmdzIHdoaWxlIHRoZSBvcmlnaW5hbCBoYW5kbGVyIGhhcyAke2hhbmRsZXJMZW5ndGh9LmBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcblxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbREVQUkVDQVRFRF0gLVxuICAgICAgICBUaGlzIGFjdGlvbiB3aWxsIGV4ZWN1dGUgeW91ciBob29rZWQgZnVuY3Rpb24gZ2l2ZW4gdGhlIGFycmF5IGFyZ3VtZW50LlxuICAgICAgICBJZiB5b3UgaW50ZW5kZWQgdG8gaG9vayBhbiBhcnJheSBvZiBmdW5jdGlvbnMgaW5zdGVhZC5cbiAgICAgICAgUGxlYXNlIHVzZSBiZWZvcmVIb29rLmdldE5ldy5gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEZPRGlzcGF0Y2goLi4uYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKGlzSGFuZGxlckZlZCA9PT0gdHJ1ZSAmJiBhcmdzWzBdW1NZTUJPTF9NSURETEVXQVJFX0lEXSAhPT0gdHJ1ZSkge1xuICAgICAgLyogdGhlbiB3ZSBhc3N1bWUgdGhpcyBzY2VuYXJpbyBjYWxscyBmb3IgYSBuZXcgaW5zdGFuY2UgKi9cbiAgICAgIHJldHVybiBDcmVhdGVJbnN0YW5jZShvcHRpb25zKShhcmdzWzBdKTtcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgKi9cbiAgICBoYW5kbGVyID0gYXJnc1swXTtcblxuICAgIGlzSGFuZGxlckZlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gRk9EaXNwYXRjaDtcbiAgfTtcblxuICBGT0luaXRCZWZvcmVIb29rLmdldE5ldyA9IChhcnJheU9mRnVuY3Rpb25zKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZGdW5jdGlvbnMpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0aW5nIGFuIGFycmF5IGFyZ3VtZW50IGJ1dCB0eXBlIFwiJHt0eXBlb2YgYXJyYXlPZkZ1bmN0aW9uc31cIiB3YXMgcGFzc2VkLmApO1xuICAgIH1cblxuICAgIGlmIChhcnJheU9mRnVuY3Rpb25zLmV2ZXJ5KGZuID0+IHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgY29uc3QgRk9BcnJheSA9IGFycmF5T2ZGdW5jdGlvbnMubWFwKGl0ZW0gPT4gQ3JlYXRlSW5zdGFuY2Uob3B0aW9ucykoaXRlbSkpO1xuICAgICAgRk9BcnJheS51c2UgPSAoLi4udXNlQXJncykgPT4ge1xuICAgICAgICBjb25zdCBGT0FycmF5SW5uZXIgPSBGT0FycmF5Lm1hcChpbnN0YW5jZSA9PlxuICAgICAgICAgIGluc3RhbmNlLnVzZSguLi51c2VBcmdzKVxuICAgICAgICApO1xuICAgICAgICBGT0FycmF5SW5uZXIudXNlID0gRk9BcnJheS51c2U7XG4gICAgICAgIHJldHVybiBGT0FycmF5SW5uZXI7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gRk9BcnJheTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBcImJlZm9yZS1ob29rIGNhbiBvbmx5IGJlIHVzZWQgZm9yIGZ1bmN0aW9ucy4gT25lIG9mIHRoZSBpdGVtcyBpbiBhcnJheSBpcyBub3QuXCJcbiAgICApO1xuICB9XG5cbiAgRk9Jbml0QmVmb3JlSG9vay51c2UgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmICghYXJncyB8fCAhYXJnc1swXSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGAudXNlIGV4cGVjdHMgYW4gaW5zdGFuY2UgZnJvbSBCYXNlTWlkZGxld2FyZS4gKEdvdCB0eXBlIFwiJHt0eXBlb2YgYXJnc1swXX1cIilgXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc0hhbmRsZXJGZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkEgaGFuZGxlciBuZWVkcyB0byBiZSBmZWQgZmlyc3QgYmVmb3JlIGNhbGxpbmcgLnVzZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICBwdnRMb2dnZXIubG9nV2FybmluZyhcbiAgICAgICAgYElnbm9yaW5nIDJuZCBhcmd1bWVudC4gXCJ1c2VcIiBtZXRob2Qgd2FzIGNhbGxlZCB3aXRoIG1vcmUgdGhhbiAxIGFyZ3VtZW50LmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwdnREaXNwYXRjaGVkID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJVc2luZyBtaWRkbGV3YXJlcyBhZ2FpbiBhZnRlciBoYW5kbGVyJ3MgaW52b2NhdGlvbiBpcyBub3QgYWxsb3dlZC5cIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBtaWRkbGV3YXJlID0gYXJnc1swXTtcblxuICAgIGlmIChtaWRkbGV3YXJlW1NZTUJPTF9NSURETEVXQVJFX0lEXSA9PT0gdHJ1ZSkge1xuICAgICAgc3RhY2tlZEhvb2tzLnB1c2gobWlkZGxld2FyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIlVua25vd24gbWlkZGxld2FyZS4gTWlkZGxld2FyZXMgbXVzdCBleHRlbmQgQmFzZU1pZGRsZXdhcmUuXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZPSW5pdEJlZm9yZUhvb2s7XG4gIH07XG5cbiAgRk9Jbml0QmVmb3JlSG9vay5zZXRMb2dnZXIgPSBuZXdMb2dnZXIgPT4ge1xuICAgIHB2dExvZ2dlciA9IG5ld0xvZ2dlcjtcbiAgfTtcblxuICBGT0luaXRCZWZvcmVIb29rLmdldExvZ2dlciA9ICgpID0+IHB2dExvZ2dlcjtcblxuICBGT0Rpc3BhdGNoID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgaG9va0JlZm9yZUNhdGNoaW5nID0ge307XG4gICAgcHZ0RGlzcGF0Y2hlZCA9IHRydWU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZXR0aW5ncy5yZWdpc3RlcikgJiYgc2V0dGluZ3MucmVnaXN0ZXIubGVuZ3RoKSB7XG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IGxvYWRpbmcgYXN5bmMgcGx1Z2luc1xuICAgICAgc2V0dGluZ3MucmVnaXN0ZXIuZm9yRWFjaChwbHVnaW5GbiA9PiB7XG4gICAgICAgIHBsdWdpbkZuKHtcbiAgICAgICAgICBnZXRQYXJhbXM6ICgpID0+IGFyZ3MsXG4gICAgICAgICAgYWRkVHJlZTogc2V0U3RhdGVUcmVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuICAgICAgZm9yIChjb25zdCBob29rIG9mIHN0YWNrZWRIb29rcykge1xuICAgICAgICBob29rQmVmb3JlQ2F0Y2hpbmcgPSBob29rO1xuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hd2FpdC1pbi1sb29wICovXG4gICAgICAgIGF3YWl0IGhvb2soeyBnZXRTdGF0ZVRyZWUgfSwgLi4uYXJncyk7XG4gICAgICAgIC8vIGNvbnN0IGV4dGVuc2lvbnMgPSBhd2FpdCBob29rKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKG1pZGRsZXdhcmVzVGhyb3cpIHtcbiAgICAgIGlmIChtaWRkbGV3YXJlc1Rocm93W1NZTUJPTF9TSE9SVF9DSVJDVUlUX1RZUEVdID09PSBcInJlcGx5XCIpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0b3BPbkNhdGNoID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uUmVwbHkoSlNPTi5wYXJzZShtaWRkbGV3YXJlc1Rocm93Lm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjYXRjaEhhbmRsZXJUb1VzZSA9XG4gICAgICAgIHR5cGVvZiBob29rQmVmb3JlQ2F0Y2hpbmdbU1lNQk9MX01JRERMRVdBUkVfT05fQ0FUQ0hdID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IChlcnIsIHBhcmFtcykgPT5cbiAgICAgICAgICAgICAgaG9va0JlZm9yZUNhdGNoaW5nW1NZTUJPTF9NSURETEVXQVJFX09OX0NBVENIXShcbiAgICAgICAgICAgICAgICBlID0+IG9uQ2F0Y2goZSwgcGFyYW1zKSxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICA6IChlcnIsIHBhcmFtcykgPT4gb25DYXRjaChlcnIsIHBhcmFtcyk7XG4gICAgICBpZiAoc2V0dGluZ3Muc3RvcE9uQ2F0Y2ggPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGNhdGNoSGFuZGxlclRvVXNlKG1pZGRsZXdhcmVzVGhyb3csIHtcbiAgICAgICAgICBnZXRQYXJhbXM6ICgpID0+IGFyZ3NcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYXRjaEhhbmRsZXJUb1VzZShtaWRkbGV3YXJlc1Rocm93LCB7XG4gICAgICAgIGdldFBhcmFtczogKCkgPT4gYXJnc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZXJDYWxsV3JhcHBlciguLi5hcmdzKTtcbiAgfTtcblxuICAvKiBjb3B5IHByb3BlcnRpZXMgb2YgRk9Jbml0QmVmb3JlSG9vayB0byBGT0Rpc3BhdGNoIC0gc28gd2UgY2FuIGNoYWluIC51c2UgYW5kIGV0YyAqL1xuICBPYmplY3Qua2V5cyhGT0luaXRCZWZvcmVIb29rKS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgRk9EaXNwYXRjaFttZXRob2RdID0gRk9Jbml0QmVmb3JlSG9va1ttZXRob2RdO1xuICB9KTtcblxuICAvKipcbiAgICpcbiAgICogQ09SRSAtIEVORFxuICAgKlxuICAgKiAqL1xuXG4gIHJldHVybiBGT0luaXRCZWZvcmVIb29rO1xufTtcblxuZXhwb3J0IHsgQmFzZU1pZGRsZXdhcmUsIEJvZHlQYXJzZXJNaWRkbGV3YXJlLCBDcmVhdGVJbnN0YW5jZSB9O1xuXG5leHBvcnQgZGVmYXVsdCBDcmVhdGVJbnN0YW5jZTtcbiJdfQ==
